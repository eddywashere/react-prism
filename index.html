<!DOCTYPE html><html><head><title>React Prism | tomchentw</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charset="UTF-8"/><link rel="stylesheet" href="assets/client-c45f26a03df5cb3b3782.css"/><script src="assets/prism-fb2fedd6acfb2d15704f.js"></script></head><body><div id="react-container"><div class="container-fluid container--full-height" data-reactid=".jmm43ifgn4" data-react-checksum="-1310859603"><div class="github-fork-ribbon-wrapper right" style="width:150px;height:150px;position:absolute;overflow:hidden;top:0px;z-index:9999;pointer-events:none;right:0px;" data-reactid=".jmm43ifgn4.0"><div class="github-fork-ribbon" style="position:absolute;padding:2px 0;background-color:#333;background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));-webkit-box-shadow:0 2px 3px 0 rgba(0, 0, 0, 0.5);-moz-box-shadow:0 2px 3px 0 rgba(0, 0, 0, 0.5);box-shadow:0 2px 3px 0 rgba(0, 0, 0, 0.5);font:700 13px &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;z-index:9999;pointer-events:auto;top:42px;right:-43px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);-o-transform:rotate(45deg);transform:rotate(45deg);" data-reactid=".jmm43ifgn4.0.0"><a href="https://github.com/tomchentw/react-prism" style="color:#fff;text-decoration:none;text-shadow:0 -1px rgba(0, 0, 0, 0.5);text-align:center;width:200px;line-height:20px;display:inline-block;padding:2px 0;border-width:1px 0;border-style:dotted;border-color:rgba(255, 255, 255, 0.7);" data-reactid=".jmm43ifgn4.0.0.0">Fork me on GitHub</a></div></div><div class="row row--full-height" data-reactid=".jmm43ifgn4.1"><div class="col-xs-6" data-reactid=".jmm43ifgn4.1.0"><h2 data-reactid=".jmm43ifgn4.1.0.0"><span data-reactid=".jmm43ifgn4.1.0.0.0">Demo of SelfUpdatedCode</span><br data-reactid=".jmm43ifgn4.1.0.0.1"/><small data-reactid=".jmm43ifgn4.1.0.0.2"><span data-reactid=".jmm43ifgn4.1.0.0.2.0">update every </span><span data-reactid=".jmm43ifgn4.1.0.0.2.1">2</span><span data-reactid=".jmm43ifgn4.1.0.0.2.2"> seconds</span></small></h2><pre data-reactid=".jmm43ifgn4.1.0.1"><code class="language-javascript" data-reactid=".jmm43ifgn4.1.0.1.0">
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== &#x27;undefined&#x27;)
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== &#x27;undefined&#x27; &amp;&amp; self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === &#x27;Array&#x27;) {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&amp;/g, &#x27;&amp;amp;&#x27;).replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/\u00a0/g, &#x27; &#x27;);
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case &#x27;Object&#x27;:
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case &#x27;Array&#x27;:
					// Check for existence for IE8
					return o.map &amp;&amp; o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];
			
			if (arguments.length == 2) {
				insert = arguments[1];
				
				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}
				
				return grammar;
			}
			
			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}
			
			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] &amp;&amp; key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type) {
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === &#x27;Object&#x27;) {
						_.languages.DFS(o[i], callback);
					}
					else if (_.util.type(o[i]) === &#x27;Array&#x27;) {
						_.languages.DFS(o[i], callback, i);
					}
				}
			}
		}
	},
	plugins: {},
	
	highlightAll: function(async, callback) {
		var elements = document.querySelectorAll(&#x27;code[class*=&quot;language-&quot;], [class*=&quot;language-&quot;] code, code[class*=&quot;lang-&quot;], [class*=&quot;lang-&quot;] code&#x27;);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent &amp;&amp; !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,&#x27;&#x27;])[1];
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, &#x27;&#x27;).replace(/\s+/g, &#x27; &#x27;) + &#x27; language-&#x27; + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, &#x27;&#x27;).replace(/\s+/g, &#x27; &#x27;) + &#x27; language-&#x27; + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		if (!code || !grammar) {
			_.hooks.run(&#x27;complete&#x27;, env);
			return;
		}

		_.hooks.run(&#x27;before-highlight&#x27;, env);

		if (async &amp;&amp; _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run(&#x27;before-insert&#x27;, env);

				env.element.innerHTML = env.highlightedCode;

				callback &amp;&amp; callback.call(env.element);
				_.hooks.run(&#x27;after-highlight&#x27;, env);
				_.hooks.run(&#x27;complete&#x27;, env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run(&#x27;before-insert&#x27;, env);

			env.element.innerHTML = env.highlightedCode;

			callback &amp;&amp; callback.call(element);

			_.hooks.run(&#x27;after-highlight&#x27;, env);
			_.hooks.run(&#x27;complete&#x27;, env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === &quot;Array&quot;) ? patterns : [patterns];

			for (var j = 0; j &lt; patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					lookbehindLength = 0,
					alias = pattern.alias;

				pattern = pattern.pattern || pattern;

				for (var i=0; i&lt;strarr.length; i++) { // Don’t cache length as it changes during the loop

					var str = strarr[i];

					if (strarr.length &gt; text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str);

					if (match) {
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}

						var from = match.index - 1 + lookbehindLength,
							match = match[0].slice(lookbehindLength),
							len = match.length,
							to = from + len,
							before = str.slice(0, from + 1),
							after = str.slice(to + 1);

						var args = [i, 1];

						if (before) {
							args.push(before);
						}

						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);

						args.push(wrapped);

						if (after) {
							args.push(after);
						}

						Array.prototype.splice.apply(strarr, args);
					}
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias) {
	this.type = type;
	this.content = content;
	this.alias = alias;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == &#x27;string&#x27;) {
		return o;
	}

	if (_.util.type(o) === &#x27;Array&#x27;) {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join(&#x27;&#x27;);
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: &#x27;span&#x27;,
		classes: [&#x27;token&#x27;, o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == &#x27;comment&#x27;) {
		env.attributes[&#x27;spellcheck&#x27;] = &#x27;true&#x27;;
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === &#x27;Array&#x27; ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run(&#x27;wrap&#x27;, env);

	var attributes = &#x27;&#x27;;

	for (var name in env.attributes) {
		attributes += (attributes ? &#x27; &#x27; : &#x27;&#x27;) + name + &#x27;=&quot;&#x27; + (env.attributes[name] || &#x27;&#x27;) + &#x27;&quot;&#x27;;
	}

	return &#x27;&lt;&#x27; + env.tag + &#x27; class=&quot;&#x27; + env.classes.join(&#x27; &#x27;) + &#x27;&quot; &#x27; + attributes + &#x27;&gt;&#x27; + env.content + &#x27;&lt;/&#x27; + env.tag + &#x27;&gt;&#x27;;

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener(&#x27;message&#x27;, function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

// Get current script and highlight
var script = document.getElementsByTagName(&#x27;script&#x27;);

script = script[script.length - 1];

if (script) {
	_.filename = script.src;

	if (document.addEventListener &amp;&amp; !script.hasAttribute(&#x27;data-manual&#x27;)) {
		document.addEventListener(&#x27;DOMContentLoaded&#x27;, _.highlightAll);
	}
}

return _self.Prism;

})();

if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== &#x27;undefined&#x27;) {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	&#x27;comment&#x27;: /&lt;!--[\w\W]*?--&gt;/,
	&#x27;prolog&#x27;: /&lt;\?[\w\W]+?\?&gt;/,
	&#x27;doctype&#x27;: /&lt;!DOCTYPE[\w\W]+?&gt;/,
	&#x27;cdata&#x27;: /&lt;!\[CDATA\[[\w\W]*?]]&gt;/i,
	&#x27;tag&#x27;: {
		pattern: /&lt;\/?[^\s&gt;\/=.]+(?:\s+[^\s&gt;\/=]+(?:=(?:(&quot;|&#x27;)(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s&#x27;&quot;&gt;=]+))?)*\s*\/?&gt;/i,
		inside: {
			&#x27;tag&#x27;: {
				pattern: /^&lt;\/?[^\s&gt;\/]+/i,
				inside: {
					&#x27;punctuation&#x27;: /^&lt;\/?/,
					&#x27;namespace&#x27;: /^[^\s&gt;\/:]+:/
				}
			},
			&#x27;attr-value&#x27;: {
				pattern: /=(?:(&#x27;|&quot;)[\w\W]*?(\1)|[^\s&gt;]+)/i,
				inside: {
					&#x27;punctuation&#x27;: /[=&gt;&quot;&#x27;]/
				}
			},
			&#x27;punctuation&#x27;: /\/?&gt;/,
			&#x27;attr-name&#x27;: {
				pattern: /[^\s&gt;\/]+/,
				inside: {
					&#x27;namespace&#x27;: /^[^\s&gt;\/:]+:/
				}
			}

		}
	},
	&#x27;entity&#x27;: /&amp;#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add(&#x27;wrap&#x27;, function(env) {

	if (env.type === &#x27;entity&#x27;) {
		env.attributes[&#x27;title&#x27;] = env.content.replace(/&amp;amp;/, &#x27;&amp;&#x27;);
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	&#x27;comment&#x27;: /\/\*[\w\W]*?\*\//,
	&#x27;atrule&#x27;: {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			&#x27;rule&#x27;: /@[\w-]+/
			// See rest below
		}
	},
	&#x27;url&#x27;: /url\((?:([&quot;&#x27;])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	&#x27;selector&#x27;: /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	&#x27;string&#x27;: /(&quot;|&#x27;)(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
	&#x27;property&#x27;: /(\b|\B)[\w-]+(?=\s*:)/i,
	&#x27;important&#x27;: /\B!important\b/i,
	&#x27;function&#x27;: /[-a-z0-9]+(?=\()/i,
	&#x27;punctuation&#x27;: /[(){};:]/
};

Prism.languages.css[&#x27;atrule&#x27;].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore(&#x27;markup&#x27;, &#x27;tag&#x27;, {
		&#x27;style&#x27;: {
			pattern: /(&lt;style[\w\W]*?&gt;)[\w\W]*?(?=&lt;\/style&gt;)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: &#x27;language-css&#x27;
		}
	});
	
	Prism.languages.insertBefore(&#x27;inside&#x27;, &#x27;attr-value&#x27;, {
		&#x27;style-attr&#x27;: {
			pattern: /\s*style=(&quot;|&#x27;).*?\1/i,
			inside: {
				&#x27;attr-name&#x27;: {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				&#x27;punctuation&#x27;: /^\s*=\s*[&#x27;&quot;]|[&#x27;&quot;]\s*$/,
				&#x27;attr-value&#x27;: {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: &#x27;language-css&#x27;
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	&#x27;comment&#x27;: [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	&#x27;string&#x27;: /([&quot;&#x27;])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	&#x27;class-name&#x27;: {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	&#x27;keyword&#x27;: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	&#x27;boolean&#x27;: /\b(true|false)\b/,
	&#x27;function&#x27;: /[a-z0-9_]+(?=\()/i,
	&#x27;number&#x27;: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	&#x27;operator&#x27;: /--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,
	&#x27;punctuation&#x27;: /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend(&#x27;clike&#x27;, {
	&#x27;keyword&#x27;: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/,
	&#x27;number&#x27;: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	&#x27;function&#x27;: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i
});

Prism.languages.insertBefore(&#x27;javascript&#x27;, &#x27;keyword&#x27;, {
	&#x27;regex&#x27;: {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true
	}
});

Prism.languages.insertBefore(&#x27;javascript&#x27;, &#x27;class-name&#x27;, {
	&#x27;template-string&#x27;: {
		pattern: /`(?:\\`|\\?[^`])*`/,
		inside: {
			&#x27;interpolation&#x27;: {
				pattern: /\$\{[^}]+\}/,
				inside: {
					&#x27;interpolation-punctuation&#x27;: {
						pattern: /^\$\{|\}$/,
						alias: &#x27;punctuation&#x27;
					},
					rest: Prism.languages.javascript
				}
			},
			&#x27;string&#x27;: /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore(&#x27;markup&#x27;, &#x27;tag&#x27;, {
		&#x27;script&#x27;: {
			pattern: /(&lt;script[\w\W]*?&gt;)[\w\W]*?(?=&lt;\/script&gt;)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: &#x27;language-javascript&#x27;
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === &#x27;undefined&#x27; || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			&#x27;js&#x27;: &#x27;javascript&#x27;,
			&#x27;html&#x27;: &#x27;markup&#x27;,
			&#x27;svg&#x27;: &#x27;markup&#x27;,
			&#x27;xml&#x27;: &#x27;markup&#x27;,
			&#x27;py&#x27;: &#x27;python&#x27;,
			&#x27;rb&#x27;: &#x27;ruby&#x27;,
			&#x27;ps1&#x27;: &#x27;powershell&#x27;,
			&#x27;psm1&#x27;: &#x27;powershell&#x27;
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll(&#x27;pre[data-src]&#x27;)).forEach(function (pre) {
				var src = pre.getAttribute(&#x27;data-src&#x27;);

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent &amp;&amp; !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, &#x27;&#x27;])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, &#x27;&#x27;])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement(&#x27;code&#x27;);
				code.className = &#x27;language-&#x27; + language;

				pre.textContent = &#x27;&#x27;;

				code.textContent = &#x27;Loading…&#x27;;

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open(&#x27;GET&#x27;, src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status &lt; 400 &amp;&amp; xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status &gt;= 400) {
							code.textContent = &#x27;✖ Error &#x27; + xhr.status + &#x27; while fetching file: &#x27; + xhr.statusText;
						}
						else {
							code.textContent = &#x27;✖ Error: File does not exist or is empty&#x27;;
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	self.Prism.fileHighlight();

})();
</code></pre></div><div class="col-xs-6" data-reactid=".jmm43ifgn4.1.1"><h2 data-reactid=".jmm43ifgn4.1.1.0"><span data-reactid=".jmm43ifgn4.1.1.0.0">Usage of PrismCode</span><br data-reactid=".jmm43ifgn4.1.1.0.1"/><small data-reactid=".jmm43ifgn4.1.1.0.2">by creating a component SelfUpdatedCode</small></h2><pre data-reactid=".jmm43ifgn4.1.1.1"><code class="language-javascript" data-reactid=".jmm43ifgn4.1.1.1.0">import {default as React, PropTypes} from &quot;react&quot;;

import {PrismCode} from &quot;../../../../src/index&quot;;

const CODE_LIST = [
  {
    className: &quot;language-javascript&quot;,
    codeBlock: require(&quot;raw-loader!prismjs/prism.js&quot;),
  },
  {
    className: &quot;language-css&quot;,
    codeBlock: require(&quot;raw-loader!../texts/prism.text&quot;),
  },
  {
    className: &quot;language-markup&quot;,
    codeBlock: require(&quot;raw-loader!../texts/markup.text&quot;),
  }
];

const CODE_LIST_LENGTH = CODE_LIST.length;

class SelfUpdatedCode extends React.Component {

  static get propTypes () {
    return {
      intervalMillis: React.PropTypes.number.isRequired,
    };
  }

  constructor (...args) {
    super(...args);
    this.state = {
      _index: 0,
      _intervalId: null,
    };
  }

  componentDidMount () {
    this._setInterval();
  }

  componentWillReceiveProps (nextProps) {
    if (nextProps.intervalMillis !== this.props.intervalMillis) {
      this._clearInterval();
      this.setState({ _intervalId: null });
    }
  }

  componentDidUpdate () {
    this._setInterval();
  }

  componentWillUnmount () {
    this._clearInterval();
  }

  _setInterval () {
    if (this.state._intervalId !== null) {
      return;
    }
    const _intervalId = setInterval(() =&gt; {
      this.setState({_index: (this.state._index + 1) % CODE_LIST_LENGTH});
    }, this.props.intervalMillis);
    this.setState({ _intervalId });
  }

  _clearInterval () {
    clearInterval(this.state._intervalId);
  }

  render () {
    const {props, state} = this;
    const {className, codeBlock} = CODE_LIST[state._index];
    return (
      &lt;PrismCode className={className}&gt;{codeBlock}&lt;/PrismCode&gt;
    );
  }
}

export default SelfUpdatedCode;
</code></pre></div></div></div></div><script src="assets/client-c45f26a03df5cb3b3782.js"></script></body></html>