module.exports=function(n){function e(a){if(t[a])return t[a].exports;var r=t[a]={exports:{},id:a,loaded:!1};return n[a].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var t={};return e.m=n,e.c=t,e.p="",e(0)}([function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}Object.defineProperty(e,"__esModule",{value:!0});var r=t(1),o=(a(r),t(3)),i=a(o);e["default"]=i["default"],n.exports=e["default"]},function(n,e){n.exports=require("react")},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}Object.defineProperty(e,"__esModule",{value:!0});var r=t(9),o=a(r),i=o["default"].createClass({displayName:"PrismCode",mixins:[r.addons.PureRenderMixin],propTypes:{async:r.PropTypes.bool},getDefaultProps:function(){return{async:!0}},componentDidMount:function(){this._hightlight()},componentDidUpdate:function(){this._hightlight()},_hightlight:function(){Prism.highlightElement(this.refs.code.getDOMNode(),this.props.async)},render:function(){var n=this.props;this.state;return o["default"].createElement("code",{ref:"code",className:n.className},n.children)}});e["default"]=i,n.exports=e["default"]},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function o(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(n.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=t(1),l=a(s),c=t(2),u=a(c),p=t(4),g=a(p),d=function(n){function e(){r(this,e),null!=n&&n.apply(this,arguments)}return o(e,n),i(e,[{key:"render",value:function(){var n=this.props,e=(this.state,n.intervalSeconds);return l["default"].createElement("div",{className:"container-fluid container--full-height"},l["default"].createElement("div",{className:"github-fork-ribbon-wrapper right"},l["default"].createElement("div",{className:"github-fork-ribbon",style:{backgroundColor:"#333"}},l["default"].createElement("a",{href:"https://github.com/tomchentw/react-prism"},"Fork me on GitHub"))),l["default"].createElement("div",{className:"row row--full-height"},l["default"].createElement("div",{className:"col-xs-6"},l["default"].createElement("h2",null,"Demo of SelfUpdatedCode",l["default"].createElement("br",null),l["default"].createElement("small",null,"update every ",e," seconds")),l["default"].createElement("pre",null,l["default"].createElement(g["default"],{intervalMillis:1e3*e}))),l["default"].createElement("div",{className:"col-xs-6"},l["default"].createElement("h2",null,"Usage of PrismCode",l["default"].createElement("br",null),l["default"].createElement("small",null,"by creating a component SelfUpdatedCode")),l["default"].createElement("pre",null,l["default"].createElement(u["default"],{className:"language-javascript"},t(6))))))}}],[{key:"propTypes",get:function(){return{intervalSeconds:s.PropTypes.number.isRequired}}}]),e}(l["default"].Component);e["default"]=d,n.exports=e["default"]},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function o(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(n.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=function(n,e,t){for(var a=!0;a;){var r=n,o=e,i=t;s=c=l=void 0,a=!1;var s=Object.getOwnPropertyDescriptor(r,o);if(void 0!==s){if("value"in s)return s.value;var l=s.get;return void 0===l?void 0:l.call(i)}var c=Object.getPrototypeOf(r);if(null===c)return void 0;n=c,e=o,t=i,a=!0}},l=t(1),c=a(l),u=t(2),p=a(u),g=[{className:"language-javascript",codeBlock:t(5)},{className:"language-css",codeBlock:t(8)},{className:"language-markup",codeBlock:t(7)}],d=g.length,f=function(n){function e(){for(var n=arguments.length,t=Array(n),a=0;n>a;a++)t[a]=arguments[a];r(this,e),s(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,t),this.state={_index:0,_intervalId:null}}return o(e,n),i(e,[{key:"componentDidMount",value:function(){this._setInterval()}},{key:"componentWillReceiveProps",value:function(n){n.intervalMillis!==this.props.intervalMillis&&(this._clearInterval(),this.setState({_intervalId:null}))}},{key:"componentDidUpdate",value:function(){this._setInterval()}},{key:"componentWillUnmount",value:function(){this._clearInterval()}},{key:"_setInterval",value:function(){var n=this;if(null===this.state._intervalId){var e=setInterval(function(){n.setState({_index:(n.state._index+1)%d})},this.props.intervalMillis);this.setState({_intervalId:e})}}},{key:"_clearInterval",value:function(){clearInterval(this.state._intervalId)}},{key:"render",value:function(){var n=(this.props,this.state),e=g[n._index],t=e.className,a=e.codeBlock;return c["default"].createElement(p["default"],{className:t},a)}}],[{key:"propTypes",get:function(){return{intervalMillis:c["default"].PropTypes.number.isRequired}}}]),e}(c["default"].Component);e["default"]=f,n.exports=e["default"]},function(n,e){n.exports="\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nself = (typeof window !== 'undefined')\n	? window   // if in browser\n	: (\n		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n		? self // if in worker\n		: {}   // if in node js\n	);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\nvar _ = self.Prism = {\n	util: {\n		encode: function (tokens) {\n			if (tokens instanceof Token) {\n				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n			} else if (_.util.type(tokens) === 'Array') {\n				return tokens.map(_.util.encode);\n			} else {\n				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n			}\n		},\n\n		type: function (o) {\n			return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n		},\n\n		// Deep clone a language definition (e.g. to extend it)\n		clone: function (o) {\n			var type = _.util.type(o);\n\n			switch (type) {\n				case 'Object':\n					var clone = {};\n\n					for (var key in o) {\n						if (o.hasOwnProperty(key)) {\n							clone[key] = _.util.clone(o[key]);\n						}\n					}\n\n					return clone;\n\n				case 'Array':\n					return o.map(function(v) { return _.util.clone(v); });\n			}\n\n			return o;\n		}\n	},\n\n	languages: {\n		extend: function (id, redef) {\n			var lang = _.util.clone(_.languages[id]);\n\n			for (var key in redef) {\n				lang[key] = redef[key];\n			}\n\n			return lang;\n		},\n\n		/**\n		 * Insert a token before another token in a language literal\n		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n		 * we cannot just provide an object, we need anobject and a key.\n		 * @param inside The key (or language id) of the parent\n		 * @param before The key to insert before. If not provided, the function appends instead.\n		 * @param insert Object with the key/value pairs to insert\n		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n		 */\n		insertBefore: function (inside, before, insert, root) {\n			root = root || _.languages;\n			var grammar = root[inside];\n			\n			if (arguments.length == 2) {\n				insert = arguments[1];\n				\n				for (var newToken in insert) {\n					if (insert.hasOwnProperty(newToken)) {\n						grammar[newToken] = insert[newToken];\n					}\n				}\n				\n				return grammar;\n			}\n			\n			var ret = {};\n\n			for (var token in grammar) {\n\n				if (grammar.hasOwnProperty(token)) {\n\n					if (token == before) {\n\n						for (var newToken in insert) {\n\n							if (insert.hasOwnProperty(newToken)) {\n								ret[newToken] = insert[newToken];\n							}\n						}\n					}\n\n					ret[token] = grammar[token];\n				}\n			}\n			\n			// Update references in other language definitions\n			_.languages.DFS(_.languages, function(key, value) {\n				if (value === root[inside] && key != inside) {\n					this[key] = ret;\n				}\n			});\n\n			return root[inside] = ret;\n		},\n\n		// Traverse a language definition with Depth First Search\n		DFS: function(o, callback, type) {\n			for (var i in o) {\n				if (o.hasOwnProperty(i)) {\n					callback.call(o, i, o[i], type || i);\n\n					if (_.util.type(o[i]) === 'Object') {\n						_.languages.DFS(o[i], callback);\n					}\n					else if (_.util.type(o[i]) === 'Array') {\n						_.languages.DFS(o[i], callback, i);\n					}\n				}\n			}\n		}\n	},\n\n	highlightAll: function(async, callback) {\n		var elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\n		for (var i=0, element; element = elements[i++];) {\n			_.highlightElement(element, async === true, callback);\n		}\n	},\n\n	highlightElement: function(element, async, callback) {\n		// Find language\n		var language, grammar, parent = element;\n\n		while (parent && !lang.test(parent.className)) {\n			parent = parent.parentNode;\n		}\n\n		if (parent) {\n			language = (parent.className.match(lang) || [,''])[1];\n			grammar = _.languages[language];\n		}\n\n		if (!grammar) {\n			return;\n		}\n\n		// Set language on the element, if not present\n		element.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n		// Set language on the parent, for styling\n		parent = element.parentNode;\n\n		if (/pre/i.test(parent.nodeName)) {\n			parent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n		}\n\n		var code = element.textContent;\n\n		if(!code) {\n			return;\n		}\n\n		code = code.replace(/^(?:\\r?\\n|\\r)/,'');\n\n		var env = {\n			element: element,\n			language: language,\n			grammar: grammar,\n			code: code\n		};\n\n		_.hooks.run('before-highlight', env);\n\n		if (async && self.Worker) {\n			var worker = new Worker(_.filename);\n\n			worker.onmessage = function(evt) {\n				env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n				_.hooks.run('before-insert', env);\n\n				env.element.innerHTML = env.highlightedCode;\n\n				callback && callback.call(env.element);\n				_.hooks.run('after-highlight', env);\n			};\n\n			worker.postMessage(JSON.stringify({\n				language: env.language,\n				code: env.code\n			}));\n		}\n		else {\n			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n			_.hooks.run('before-insert', env);\n\n			env.element.innerHTML = env.highlightedCode;\n\n			callback && callback.call(element);\n\n			_.hooks.run('after-highlight', env);\n		}\n	},\n\n	highlight: function (text, grammar, language) {\n		var tokens = _.tokenize(text, grammar);\n		return Token.stringify(_.util.encode(tokens), language);\n	},\n\n	tokenize: function(text, grammar, language) {\n		var Token = _.Token;\n\n		var strarr = [text];\n\n		var rest = grammar.rest;\n\n		if (rest) {\n			for (var token in rest) {\n				grammar[token] = rest[token];\n			}\n\n			delete grammar.rest;\n		}\n\n		tokenloop: for (var token in grammar) {\n			if(!grammar.hasOwnProperty(token) || !grammar[token]) {\n				continue;\n			}\n\n			var patterns = grammar[token];\n			patterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n			for (var j = 0; j < patterns.length; ++j) {\n				var pattern = patterns[j],\n					inside = pattern.inside,\n					lookbehind = !!pattern.lookbehind,\n					lookbehindLength = 0,\n					alias = pattern.alias;\n\n				pattern = pattern.pattern || pattern;\n\n				for (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\n\n					var str = strarr[i];\n\n					if (strarr.length > text.length) {\n						// Something went terribly wrong, ABORT, ABORT!\n						break tokenloop;\n					}\n\n					if (str instanceof Token) {\n						continue;\n					}\n\n					pattern.lastIndex = 0;\n\n					var match = pattern.exec(str);\n\n					if (match) {\n						if(lookbehind) {\n							lookbehindLength = match[1].length;\n						}\n\n						var from = match.index - 1 + lookbehindLength,\n							match = match[0].slice(lookbehindLength),\n							len = match.length,\n							to = from + len,\n							before = str.slice(0, from + 1),\n							after = str.slice(to + 1);\n\n						var args = [i, 1];\n\n						if (before) {\n							args.push(before);\n						}\n\n						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);\n\n						args.push(wrapped);\n\n						if (after) {\n							args.push(after);\n						}\n\n						Array.prototype.splice.apply(strarr, args);\n					}\n				}\n			}\n		}\n\n		return strarr;\n	},\n\n	hooks: {\n		all: {},\n\n		add: function (name, callback) {\n			var hooks = _.hooks.all;\n\n			hooks[name] = hooks[name] || [];\n\n			hooks[name].push(callback);\n		},\n\n		run: function (name, env) {\n			var callbacks = _.hooks.all[name];\n\n			if (!callbacks || !callbacks.length) {\n				return;\n			}\n\n			for (var i=0, callback; callback = callbacks[i++];) {\n				callback(env);\n			}\n		}\n	}\n};\n\nvar Token = _.Token = function(type, content, alias) {\n	this.type = type;\n	this.content = content;\n	this.alias = alias;\n};\n\nToken.stringify = function(o, language, parent) {\n	if (typeof o == 'string') {\n		return o;\n	}\n\n	if (_.util.type(o) === 'Array') {\n		return o.map(function(element) {\n			return Token.stringify(element, language, o);\n		}).join('');\n	}\n\n	var env = {\n		type: o.type,\n		content: Token.stringify(o.content, language, parent),\n		tag: 'span',\n		classes: ['token', o.type],\n		attributes: {},\n		language: language,\n		parent: parent\n	};\n\n	if (env.type == 'comment') {\n		env.attributes['spellcheck'] = 'true';\n	}\n\n	if (o.alias) {\n		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n		Array.prototype.push.apply(env.classes, aliases);\n	}\n\n	_.hooks.run('wrap', env);\n\n	var attributes = '';\n\n	for (var name in env.attributes) {\n		attributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n	}\n\n	return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!self.document) {\n	if (!self.addEventListener) {\n		// in Node.js\n		return self.Prism;\n	}\n 	// In worker\n	self.addEventListener('message', function(evt) {\n		var message = JSON.parse(evt.data),\n		    lang = message.language,\n		    code = message.code;\n\n		self.postMessage(JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang]))));\n		self.close();\n	}, false);\n\n	return self.Prism;\n}\n\n// Get current script and highlight\nvar script = document.getElementsByTagName('script');\n\nscript = script[script.length - 1];\n\nif (script) {\n	_.filename = script.src;\n\n	if (document.addEventListener && !script.hasAttribute('data-manual')) {\n		document.addEventListener('DOMContentLoaded', _.highlightAll);\n	}\n}\n\nreturn self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n	module.exports = Prism;\n}\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n	'comment': /<!--[\\w\\W]*?-->/,\n	'prolog': /<\\?.+?\\?>/,\n	'doctype': /<!DOCTYPE.+?>/,\n	'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n	'tag': {\n		pattern: /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/i,\n		inside: {\n			'tag': {\n				pattern: /^<\\/?[\\w:-]+/i,\n				inside: {\n					'punctuation': /^<\\/?/,\n					'namespace': /^[\\w-]+?:/\n				}\n			},\n			'attr-value': {\n				pattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n				inside: {\n					'punctuation': /=|>|\"/\n				}\n			},\n			'punctuation': /\\/?>/,\n			'attr-name': {\n				pattern: /[\\w:-]+/,\n				inside: {\n					'namespace': /^[\\w-]+?:/\n				}\n			}\n\n		}\n	},\n	'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n	if (env.type === 'entity') {\n		env.attributes['title'] = env.content.replace(/&amp;/, '&');\n	}\n});\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n	'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n	'atrule': {\n		pattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n		inside: {\n			'punctuation': /[;:]/\n		}\n	},\n	'url': /url\\((?:([\"'])(\\\\\\n|\\\\?.)*?\\1|.*?)\\)/i,\n	'selector': /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/,\n	'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n	'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n	'important': /\\B!important\\b/i,\n	'punctuation': /[\\{\\};:]/,\n	'function': /[-a-z0-9]+(?=\\()/i\n};\n\nif (Prism.languages.markup) {\n	Prism.languages.insertBefore('markup', 'tag', {\n		'style': {\n			pattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/i,\n			inside: {\n				'tag': {\n					pattern: /<style[\\w\\W]*?>|<\\/style>/i,\n					inside: Prism.languages.markup.tag.inside\n				},\n				rest: Prism.languages.css\n			},\n			alias: 'language-css'\n		}\n	});\n	\n	Prism.languages.insertBefore('inside', 'attr-value', {\n		'style-attr': {\n			pattern: /\\s*style=(\"|').*?\\1/i,\n			inside: {\n				'attr-name': {\n					pattern: /^\\s*style/i,\n					inside: Prism.languages.markup.tag.inside\n				},\n				'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n				'attr-value': {\n					pattern: /.+/i,\n					inside: Prism.languages.css\n				}\n			},\n			alias: 'language-css'\n		}\n	}, Prism.languages.markup.tag);\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n	'comment': [\n		{\n			pattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n			lookbehind: true\n		},\n		{\n			pattern: /(^|[^\\\\:])\\/\\/.+/,\n			lookbehind: true\n		}\n	],\n	'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n	'class-name': {\n		pattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n		lookbehind: true,\n		inside: {\n			punctuation: /(\\.|\\\\)/\n		}\n	},\n	'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n	'boolean': /\\b(true|false)\\b/,\n	'function': {\n		pattern: /[a-z0-9_]+\\(/i,\n		inside: {\n			punctuation: /\\(/\n		}\n	},\n	'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n	'operator': /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/,\n	'ignore': /&(lt|gt|amp);/i,\n	'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n	'keyword': /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/,\n	'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|-?Infinity)\\b/,\n	'function': /(?!\\d)[a-z0-9_$]+(?=\\()/i\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n	'regex': {\n		pattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n		lookbehind: true\n	}\n});\n\nif (Prism.languages.markup) {\n	Prism.languages.insertBefore('markup', 'tag', {\n		'script': {\n			pattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/i,\n			inside: {\n				'tag': {\n					pattern: /<script[\\w\\W]*?>|<\\/script>/i,\n					inside: Prism.languages.markup.tag.inside\n				},\n				rest: Prism.languages.javascript\n			},\n			alias: 'language-javascript'\n		}\n	});\n}\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n	if (!self.Prism || !self.document || !document.querySelector) {\n		return;\n	}\n\n	self.Prism.fileHighlight = function() {\n\n		var Extensions = {\n			'js': 'javascript',\n			'html': 'markup',\n			'svg': 'markup',\n			'xml': 'markup',\n			'py': 'python',\n			'rb': 'ruby',\n			'ps1': 'powershell',\n			'psm1': 'powershell'\n		};\n\n		Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function(pre) {\n			var src = pre.getAttribute('data-src');\n			var extension = (src.match(/\\.(\\w+)$/) || [,''])[1];\n			var language = Extensions[extension] || extension;\n\n			var code = document.createElement('code');\n			code.className = 'language-' + language;\n\n			pre.textContent = '';\n\n			code.textContent = 'Loading…';\n\n			pre.appendChild(code);\n\n			var xhr = new XMLHttpRequest();\n\n			xhr.open('GET', src, true);\n\n			xhr.onreadystatechange = function() {\n				if (xhr.readyState == 4) {\n\n					if (xhr.status < 400 && xhr.responseText) {\n						code.textContent = xhr.responseText;\n\n						Prism.highlightElement(code);\n					}\n					else if (xhr.status >= 400) {\n						code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n					}\n					else {\n						code.textContent = '✖ Error: File does not exist or is empty';\n					}\n				}\n			};\n\n			xhr.send(null);\n		});\n\n	};\n\n	self.Prism.fileHighlight();\n\n})();\n"},function(n,e){n.exports='import {default as React, PropTypes} from "react";\nimport {default as PrismCode} from "react-prism/PrismCode";\n\nconst CODE_LIST = [\n  {\n    className: "language-javascript",\n    codeBlock: require("raw-loader!prismjs/prism.js"),\n  },\n  {\n    className: "language-css",\n    codeBlock: require("raw-loader!../../texts/prism.text"),\n  },\n  {\n    className: "language-markup",\n    codeBlock: require("raw-loader!../../texts/markup.text"),\n  }\n];\n\nconst CODE_LIST_LENGTH = CODE_LIST.length;\n\nclass SelfUpdatedCode extends React.Component {\n\n  static get propTypes () {\n    return {\n      intervalMillis: React.PropTypes.number.isRequired,\n    };\n  }\n\n  constructor (...args) {\n    super(...args);\n    this.state = {\n      _index: 0,\n      _intervalId: null,\n    };\n  }\n\n  componentDidMount () {\n    this._setInterval();\n  }\n\n  componentWillReceiveProps (nextProps) {\n    if (nextProps.intervalMillis !== this.props.intervalMillis) {\n      this._clearInterval();\n      this.setState({ _intervalId: null });\n    }\n  }\n\n  componentDidUpdate () {\n    this._setInterval();\n  }\n\n  componentWillUnmount () {\n    this._clearInterval();\n  }\n\n  _setInterval () {\n    if (this.state._intervalId !== null) {\n      return;\n    }\n    const _intervalId = setInterval(() => {\n      this.setState({_index: (this.state._index + 1) % CODE_LIST_LENGTH});\n    }, this.props.intervalMillis);\n    this.setState({ _intervalId });\n  }\n\n  _clearInterval () {\n    clearInterval(this.state._intervalId);\n  }\n\n  render () {\n    const {props, state} = this;\n    const {className, codeBlock} = CODE_LIST[state._index];\n    return (\n      <PrismCode className={className}>{codeBlock}</PrismCode>\n    );\n  }\n}\n\nexport default SelfUpdatedCode;\n'},function(n,e){n.exports='<!DOCTYPE html>\n<html lang="en">\n<head>\n\n<script>\n  // Just a lil’ script to show off that inline JS gets highlighted\n  window.console && console.log(\'foo\');\n</script>\n<meta charset="utf-8" />\n<link rel="shortcut icon" href="favicon.png" />\n<title>Prism</title>\n<link rel="stylesheet" href="style.css" />\n<link rel="stylesheet" href="themes/prism.css" data-noprefix />\n<script src="prefixfree.min.js"></script>\n\n<script>var _gaq = [[\'_setAccount\', \'UA-33746269-1\'], [\'_trackPageview\']];</script>\n<script src=\\"http://www.google-analytics.com/ga.js\\" async></script>\n</head>\n<body>\n</body>\n</html>\n'},function(n,e){n.exports='/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*="language-"],\npre[class*="language-"] {\n	color: black;\n	text-shadow: 0 1px white;\n	font-family: Consolas, Monaco, \'Andale Mono\', monospace;\n	direction: ltr;\n	text-align: left;\n	white-space: pre;\n	word-spacing: normal;\n	word-break: normal;\n	line-height: 1.5;\n\n	-moz-tab-size: 4;\n	-o-tab-size: 4;\n	tab-size: 4;\n\n	-webkit-hyphens: none;\n	-moz-hyphens: none;\n	-ms-hyphens: none;\n	hyphens: none;\n}\n\npre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,\ncode[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {\n	text-shadow: none;\n	background: #b3d4fc;\n}\n\npre[class*="language-"]::selection, pre[class*="language-"] ::selection,\ncode[class*="language-"]::selection, code[class*="language-"] ::selection {\n	text-shadow: none;\n	background: #b3d4fc;\n}\n\n@media print {\n	code[class*="language-"],\n	pre[class*="language-"] {\n		text-shadow: none;\n	}\n}\n\n/* Code blocks */\npre[class*="language-"] {\n	padding: 1em;\n	margin: .5em 0;\n	overflow: auto;\n}\n\n:not(pre) > code[class*="language-"],\npre[class*="language-"] {\n	background: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*="language-"] {\n	padding: .1em;\n	border-radius: .3em;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n	color: slategray;\n}\n\n.token.punctuation {\n	color: #999;\n}\n\n.namespace {\n	opacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n	color: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n	color: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n	color: #a67f59;\n	background: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n	color: #07a;\n}\n\n.token.function {\n	color: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n	color: #e90;\n}\n\n.token.important {\n	font-weight: bold;\n}\n\n.token.entity {\n	cursor: help;\n}\n'},function(n,e){n.exports=require("react/addons")}]);